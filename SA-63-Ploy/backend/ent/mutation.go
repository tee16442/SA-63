// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/Sujitnapa21/app/ent/adult"
	"github.com/Sujitnapa21/app/ent/books"
	"github.com/Sujitnapa21/app/ent/customer"
	"github.com/Sujitnapa21/app/ent/kid"
	"github.com/Sujitnapa21/app/ent/room"
	"github.com/Sujitnapa21/app/ent/roomamount"

	"github.com/facebookincubator/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAdult      = "Adult"
	TypeBooks      = "Books"
	TypeCustomer   = "Customer"
	TypeKid        = "Kid"
	TypeRoom       = "Room"
	TypeRoomamount = "Roomamount"
)

// AdultMutation represents an operation that mutate the Adults
// nodes in the graph.
type AdultMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_Amount       *int
	add_Amount    *int
	clearedFields map[string]struct{}
	books         map[int]struct{}
	removedbooks  map[int]struct{}
	done          bool
	oldValue      func(context.Context) (*Adult, error)
}

var _ ent.Mutation = (*AdultMutation)(nil)

// adultOption allows to manage the mutation configuration using functional options.
type adultOption func(*AdultMutation)

// newAdultMutation creates new mutation for $n.Name.
func newAdultMutation(c config, op Op, opts ...adultOption) *AdultMutation {
	m := &AdultMutation{
		config:        c,
		op:            op,
		typ:           TypeAdult,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAdultID sets the id field of the mutation.
func withAdultID(id int) adultOption {
	return func(m *AdultMutation) {
		var (
			err   error
			once  sync.Once
			value *Adult
		)
		m.oldValue = func(ctx context.Context) (*Adult, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Adult.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAdult sets the old Adult of the mutation.
func withAdult(node *Adult) adultOption {
	return func(m *AdultMutation) {
		m.oldValue = func(context.Context) (*Adult, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AdultMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AdultMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *AdultMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetAmount sets the Amount field.
func (m *AdultMutation) SetAmount(i int) {
	m._Amount = &i
	m.add_Amount = nil
}

// Amount returns the Amount value in the mutation.
func (m *AdultMutation) Amount() (r int, exists bool) {
	v := m._Amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old Amount value of the Adult.
// If the Adult object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AdultMutation) OldAmount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAmount is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds i to Amount.
func (m *AdultMutation) AddAmount(i int) {
	if m.add_Amount != nil {
		*m.add_Amount += i
	} else {
		m.add_Amount = &i
	}
}

// AddedAmount returns the value that was added to the Amount field in this mutation.
func (m *AdultMutation) AddedAmount() (r int, exists bool) {
	v := m.add_Amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount reset all changes of the "Amount" field.
func (m *AdultMutation) ResetAmount() {
	m._Amount = nil
	m.add_Amount = nil
}

// AddBookIDs adds the books edge to Books by ids.
func (m *AdultMutation) AddBookIDs(ids ...int) {
	if m.books == nil {
		m.books = make(map[int]struct{})
	}
	for i := range ids {
		m.books[ids[i]] = struct{}{}
	}
}

// RemoveBookIDs removes the books edge to Books by ids.
func (m *AdultMutation) RemoveBookIDs(ids ...int) {
	if m.removedbooks == nil {
		m.removedbooks = make(map[int]struct{})
	}
	for i := range ids {
		m.removedbooks[ids[i]] = struct{}{}
	}
}

// RemovedBooks returns the removed ids of books.
func (m *AdultMutation) RemovedBooksIDs() (ids []int) {
	for id := range m.removedbooks {
		ids = append(ids, id)
	}
	return
}

// BooksIDs returns the books ids in the mutation.
func (m *AdultMutation) BooksIDs() (ids []int) {
	for id := range m.books {
		ids = append(ids, id)
	}
	return
}

// ResetBooks reset all changes of the "books" edge.
func (m *AdultMutation) ResetBooks() {
	m.books = nil
	m.removedbooks = nil
}

// Op returns the operation name.
func (m *AdultMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Adult).
func (m *AdultMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *AdultMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Amount != nil {
		fields = append(fields, adult.FieldAmount)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *AdultMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case adult.FieldAmount:
		return m.Amount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *AdultMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case adult.FieldAmount:
		return m.OldAmount(ctx)
	}
	return nil, fmt.Errorf("unknown Adult field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *AdultMutation) SetField(name string, value ent.Value) error {
	switch name {
	case adult.FieldAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Adult field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *AdultMutation) AddedFields() []string {
	var fields []string
	if m.add_Amount != nil {
		fields = append(fields, adult.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *AdultMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case adult.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *AdultMutation) AddField(name string, value ent.Value) error {
	switch name {
	case adult.FieldAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Adult numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *AdultMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *AdultMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *AdultMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Adult nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *AdultMutation) ResetField(name string) error {
	switch name {
	case adult.FieldAmount:
		m.ResetAmount()
		return nil
	}
	return fmt.Errorf("unknown Adult field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *AdultMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.books != nil {
		edges = append(edges, adult.EdgeBooks)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *AdultMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case adult.EdgeBooks:
		ids := make([]ent.Value, 0, len(m.books))
		for id := range m.books {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *AdultMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedbooks != nil {
		edges = append(edges, adult.EdgeBooks)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *AdultMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case adult.EdgeBooks:
		ids := make([]ent.Value, 0, len(m.removedbooks))
		for id := range m.removedbooks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *AdultMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *AdultMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *AdultMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Adult unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *AdultMutation) ResetEdge(name string) error {
	switch name {
	case adult.EdgeBooks:
		m.ResetBooks()
		return nil
	}
	return fmt.Errorf("unknown Adult edge %s", name)
}

// BooksMutation represents an operation that mutate the BooksSlice
// nodes in the graph.
type BooksMutation struct {
	config
	op                Op
	typ               string
	id                *int
	_Checkin          *time.Time
	_Checkout         *time.Time
	clearedFields     map[string]struct{}
	customer          *int
	clearedcustomer   bool
	adult             *int
	clearedadult      bool
	kid               *int
	clearedkid        bool
	roomamount        *int
	clearedroomamount bool
	room              *int
	clearedroom       bool
	done              bool
	oldValue          func(context.Context) (*Books, error)
}

var _ ent.Mutation = (*BooksMutation)(nil)

// booksOption allows to manage the mutation configuration using functional options.
type booksOption func(*BooksMutation)

// newBooksMutation creates new mutation for $n.Name.
func newBooksMutation(c config, op Op, opts ...booksOption) *BooksMutation {
	m := &BooksMutation{
		config:        c,
		op:            op,
		typ:           TypeBooks,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBooksID sets the id field of the mutation.
func withBooksID(id int) booksOption {
	return func(m *BooksMutation) {
		var (
			err   error
			once  sync.Once
			value *Books
		)
		m.oldValue = func(ctx context.Context) (*Books, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Books.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBooks sets the old Books of the mutation.
func withBooks(node *Books) booksOption {
	return func(m *BooksMutation) {
		m.oldValue = func(context.Context) (*Books, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BooksMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BooksMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *BooksMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCheckin sets the Checkin field.
func (m *BooksMutation) SetCheckin(t time.Time) {
	m._Checkin = &t
}

// Checkin returns the Checkin value in the mutation.
func (m *BooksMutation) Checkin() (r time.Time, exists bool) {
	v := m._Checkin
	if v == nil {
		return
	}
	return *v, true
}

// OldCheckin returns the old Checkin value of the Books.
// If the Books object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BooksMutation) OldCheckin(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCheckin is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCheckin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCheckin: %w", err)
	}
	return oldValue.Checkin, nil
}

// ResetCheckin reset all changes of the "Checkin" field.
func (m *BooksMutation) ResetCheckin() {
	m._Checkin = nil
}

// SetCheckout sets the Checkout field.
func (m *BooksMutation) SetCheckout(t time.Time) {
	m._Checkout = &t
}

// Checkout returns the Checkout value in the mutation.
func (m *BooksMutation) Checkout() (r time.Time, exists bool) {
	v := m._Checkout
	if v == nil {
		return
	}
	return *v, true
}

// OldCheckout returns the old Checkout value of the Books.
// If the Books object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BooksMutation) OldCheckout(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCheckout is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCheckout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCheckout: %w", err)
	}
	return oldValue.Checkout, nil
}

// ResetCheckout reset all changes of the "Checkout" field.
func (m *BooksMutation) ResetCheckout() {
	m._Checkout = nil
}

// SetCustomerID sets the customer edge to Customer by id.
func (m *BooksMutation) SetCustomerID(id int) {
	m.customer = &id
}

// ClearCustomer clears the customer edge to Customer.
func (m *BooksMutation) ClearCustomer() {
	m.clearedcustomer = true
}

// CustomerCleared returns if the edge customer was cleared.
func (m *BooksMutation) CustomerCleared() bool {
	return m.clearedcustomer
}

// CustomerID returns the customer id in the mutation.
func (m *BooksMutation) CustomerID() (id int, exists bool) {
	if m.customer != nil {
		return *m.customer, true
	}
	return
}

// CustomerIDs returns the customer ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// CustomerID instead. It exists only for internal usage by the builders.
func (m *BooksMutation) CustomerIDs() (ids []int) {
	if id := m.customer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCustomer reset all changes of the "customer" edge.
func (m *BooksMutation) ResetCustomer() {
	m.customer = nil
	m.clearedcustomer = false
}

// SetAdultID sets the adult edge to Adult by id.
func (m *BooksMutation) SetAdultID(id int) {
	m.adult = &id
}

// ClearAdult clears the adult edge to Adult.
func (m *BooksMutation) ClearAdult() {
	m.clearedadult = true
}

// AdultCleared returns if the edge adult was cleared.
func (m *BooksMutation) AdultCleared() bool {
	return m.clearedadult
}

// AdultID returns the adult id in the mutation.
func (m *BooksMutation) AdultID() (id int, exists bool) {
	if m.adult != nil {
		return *m.adult, true
	}
	return
}

// AdultIDs returns the adult ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// AdultID instead. It exists only for internal usage by the builders.
func (m *BooksMutation) AdultIDs() (ids []int) {
	if id := m.adult; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAdult reset all changes of the "adult" edge.
func (m *BooksMutation) ResetAdult() {
	m.adult = nil
	m.clearedadult = false
}

// SetKidID sets the kid edge to Kid by id.
func (m *BooksMutation) SetKidID(id int) {
	m.kid = &id
}

// ClearKid clears the kid edge to Kid.
func (m *BooksMutation) ClearKid() {
	m.clearedkid = true
}

// KidCleared returns if the edge kid was cleared.
func (m *BooksMutation) KidCleared() bool {
	return m.clearedkid
}

// KidID returns the kid id in the mutation.
func (m *BooksMutation) KidID() (id int, exists bool) {
	if m.kid != nil {
		return *m.kid, true
	}
	return
}

// KidIDs returns the kid ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// KidID instead. It exists only for internal usage by the builders.
func (m *BooksMutation) KidIDs() (ids []int) {
	if id := m.kid; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetKid reset all changes of the "kid" edge.
func (m *BooksMutation) ResetKid() {
	m.kid = nil
	m.clearedkid = false
}

// SetRoomamountID sets the roomamount edge to Roomamount by id.
func (m *BooksMutation) SetRoomamountID(id int) {
	m.roomamount = &id
}

// ClearRoomamount clears the roomamount edge to Roomamount.
func (m *BooksMutation) ClearRoomamount() {
	m.clearedroomamount = true
}

// RoomamountCleared returns if the edge roomamount was cleared.
func (m *BooksMutation) RoomamountCleared() bool {
	return m.clearedroomamount
}

// RoomamountID returns the roomamount id in the mutation.
func (m *BooksMutation) RoomamountID() (id int, exists bool) {
	if m.roomamount != nil {
		return *m.roomamount, true
	}
	return
}

// RoomamountIDs returns the roomamount ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// RoomamountID instead. It exists only for internal usage by the builders.
func (m *BooksMutation) RoomamountIDs() (ids []int) {
	if id := m.roomamount; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRoomamount reset all changes of the "roomamount" edge.
func (m *BooksMutation) ResetRoomamount() {
	m.roomamount = nil
	m.clearedroomamount = false
}

// SetRoomID sets the room edge to Room by id.
func (m *BooksMutation) SetRoomID(id int) {
	m.room = &id
}

// ClearRoom clears the room edge to Room.
func (m *BooksMutation) ClearRoom() {
	m.clearedroom = true
}

// RoomCleared returns if the edge room was cleared.
func (m *BooksMutation) RoomCleared() bool {
	return m.clearedroom
}

// RoomID returns the room id in the mutation.
func (m *BooksMutation) RoomID() (id int, exists bool) {
	if m.room != nil {
		return *m.room, true
	}
	return
}

// RoomIDs returns the room ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// RoomID instead. It exists only for internal usage by the builders.
func (m *BooksMutation) RoomIDs() (ids []int) {
	if id := m.room; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRoom reset all changes of the "room" edge.
func (m *BooksMutation) ResetRoom() {
	m.room = nil
	m.clearedroom = false
}

// Op returns the operation name.
func (m *BooksMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Books).
func (m *BooksMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *BooksMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._Checkin != nil {
		fields = append(fields, books.FieldCheckin)
	}
	if m._Checkout != nil {
		fields = append(fields, books.FieldCheckout)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *BooksMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case books.FieldCheckin:
		return m.Checkin()
	case books.FieldCheckout:
		return m.Checkout()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *BooksMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case books.FieldCheckin:
		return m.OldCheckin(ctx)
	case books.FieldCheckout:
		return m.OldCheckout(ctx)
	}
	return nil, fmt.Errorf("unknown Books field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BooksMutation) SetField(name string, value ent.Value) error {
	switch name {
	case books.FieldCheckin:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCheckin(v)
		return nil
	case books.FieldCheckout:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCheckout(v)
		return nil
	}
	return fmt.Errorf("unknown Books field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *BooksMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *BooksMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BooksMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Books numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *BooksMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *BooksMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *BooksMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Books nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *BooksMutation) ResetField(name string) error {
	switch name {
	case books.FieldCheckin:
		m.ResetCheckin()
		return nil
	case books.FieldCheckout:
		m.ResetCheckout()
		return nil
	}
	return fmt.Errorf("unknown Books field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *BooksMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.customer != nil {
		edges = append(edges, books.EdgeCustomer)
	}
	if m.adult != nil {
		edges = append(edges, books.EdgeAdult)
	}
	if m.kid != nil {
		edges = append(edges, books.EdgeKid)
	}
	if m.roomamount != nil {
		edges = append(edges, books.EdgeRoomamount)
	}
	if m.room != nil {
		edges = append(edges, books.EdgeRoom)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *BooksMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case books.EdgeCustomer:
		if id := m.customer; id != nil {
			return []ent.Value{*id}
		}
	case books.EdgeAdult:
		if id := m.adult; id != nil {
			return []ent.Value{*id}
		}
	case books.EdgeKid:
		if id := m.kid; id != nil {
			return []ent.Value{*id}
		}
	case books.EdgeRoomamount:
		if id := m.roomamount; id != nil {
			return []ent.Value{*id}
		}
	case books.EdgeRoom:
		if id := m.room; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *BooksMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *BooksMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *BooksMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedcustomer {
		edges = append(edges, books.EdgeCustomer)
	}
	if m.clearedadult {
		edges = append(edges, books.EdgeAdult)
	}
	if m.clearedkid {
		edges = append(edges, books.EdgeKid)
	}
	if m.clearedroomamount {
		edges = append(edges, books.EdgeRoomamount)
	}
	if m.clearedroom {
		edges = append(edges, books.EdgeRoom)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *BooksMutation) EdgeCleared(name string) bool {
	switch name {
	case books.EdgeCustomer:
		return m.clearedcustomer
	case books.EdgeAdult:
		return m.clearedadult
	case books.EdgeKid:
		return m.clearedkid
	case books.EdgeRoomamount:
		return m.clearedroomamount
	case books.EdgeRoom:
		return m.clearedroom
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *BooksMutation) ClearEdge(name string) error {
	switch name {
	case books.EdgeCustomer:
		m.ClearCustomer()
		return nil
	case books.EdgeAdult:
		m.ClearAdult()
		return nil
	case books.EdgeKid:
		m.ClearKid()
		return nil
	case books.EdgeRoomamount:
		m.ClearRoomamount()
		return nil
	case books.EdgeRoom:
		m.ClearRoom()
		return nil
	}
	return fmt.Errorf("unknown Books unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *BooksMutation) ResetEdge(name string) error {
	switch name {
	case books.EdgeCustomer:
		m.ResetCustomer()
		return nil
	case books.EdgeAdult:
		m.ResetAdult()
		return nil
	case books.EdgeKid:
		m.ResetKid()
		return nil
	case books.EdgeRoomamount:
		m.ResetRoomamount()
		return nil
	case books.EdgeRoom:
		m.ResetRoom()
		return nil
	}
	return fmt.Errorf("unknown Books edge %s", name)
}

// CustomerMutation represents an operation that mutate the Customers
// nodes in the graph.
type CustomerMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_Email        *string
	_Username     *string
	clearedFields map[string]struct{}
	books         map[int]struct{}
	removedbooks  map[int]struct{}
	done          bool
	oldValue      func(context.Context) (*Customer, error)
}

var _ ent.Mutation = (*CustomerMutation)(nil)

// customerOption allows to manage the mutation configuration using functional options.
type customerOption func(*CustomerMutation)

// newCustomerMutation creates new mutation for $n.Name.
func newCustomerMutation(c config, op Op, opts ...customerOption) *CustomerMutation {
	m := &CustomerMutation{
		config:        c,
		op:            op,
		typ:           TypeCustomer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCustomerID sets the id field of the mutation.
func withCustomerID(id int) customerOption {
	return func(m *CustomerMutation) {
		var (
			err   error
			once  sync.Once
			value *Customer
		)
		m.oldValue = func(ctx context.Context) (*Customer, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Customer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCustomer sets the old Customer of the mutation.
func withCustomer(node *Customer) customerOption {
	return func(m *CustomerMutation) {
		m.oldValue = func(context.Context) (*Customer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CustomerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CustomerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CustomerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetEmail sets the Email field.
func (m *CustomerMutation) SetEmail(s string) {
	m._Email = &s
}

// Email returns the Email value in the mutation.
func (m *CustomerMutation) Email() (r string, exists bool) {
	v := m._Email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old Email value of the Customer.
// If the Customer object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CustomerMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail reset all changes of the "Email" field.
func (m *CustomerMutation) ResetEmail() {
	m._Email = nil
}

// SetUsername sets the Username field.
func (m *CustomerMutation) SetUsername(s string) {
	m._Username = &s
}

// Username returns the Username value in the mutation.
func (m *CustomerMutation) Username() (r string, exists bool) {
	v := m._Username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old Username value of the Customer.
// If the Customer object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CustomerMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUsername is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername reset all changes of the "Username" field.
func (m *CustomerMutation) ResetUsername() {
	m._Username = nil
}

// AddBookIDs adds the books edge to Books by ids.
func (m *CustomerMutation) AddBookIDs(ids ...int) {
	if m.books == nil {
		m.books = make(map[int]struct{})
	}
	for i := range ids {
		m.books[ids[i]] = struct{}{}
	}
}

// RemoveBookIDs removes the books edge to Books by ids.
func (m *CustomerMutation) RemoveBookIDs(ids ...int) {
	if m.removedbooks == nil {
		m.removedbooks = make(map[int]struct{})
	}
	for i := range ids {
		m.removedbooks[ids[i]] = struct{}{}
	}
}

// RemovedBooks returns the removed ids of books.
func (m *CustomerMutation) RemovedBooksIDs() (ids []int) {
	for id := range m.removedbooks {
		ids = append(ids, id)
	}
	return
}

// BooksIDs returns the books ids in the mutation.
func (m *CustomerMutation) BooksIDs() (ids []int) {
	for id := range m.books {
		ids = append(ids, id)
	}
	return
}

// ResetBooks reset all changes of the "books" edge.
func (m *CustomerMutation) ResetBooks() {
	m.books = nil
	m.removedbooks = nil
}

// Op returns the operation name.
func (m *CustomerMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Customer).
func (m *CustomerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CustomerMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._Email != nil {
		fields = append(fields, customer.FieldEmail)
	}
	if m._Username != nil {
		fields = append(fields, customer.FieldUsername)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CustomerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case customer.FieldEmail:
		return m.Email()
	case customer.FieldUsername:
		return m.Username()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CustomerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case customer.FieldEmail:
		return m.OldEmail(ctx)
	case customer.FieldUsername:
		return m.OldUsername(ctx)
	}
	return nil, fmt.Errorf("unknown Customer field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CustomerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case customer.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case customer.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	}
	return fmt.Errorf("unknown Customer field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CustomerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CustomerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CustomerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Customer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CustomerMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CustomerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CustomerMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Customer nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CustomerMutation) ResetField(name string) error {
	switch name {
	case customer.FieldEmail:
		m.ResetEmail()
		return nil
	case customer.FieldUsername:
		m.ResetUsername()
		return nil
	}
	return fmt.Errorf("unknown Customer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CustomerMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.books != nil {
		edges = append(edges, customer.EdgeBooks)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CustomerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case customer.EdgeBooks:
		ids := make([]ent.Value, 0, len(m.books))
		for id := range m.books {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CustomerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedbooks != nil {
		edges = append(edges, customer.EdgeBooks)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CustomerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case customer.EdgeBooks:
		ids := make([]ent.Value, 0, len(m.removedbooks))
		for id := range m.removedbooks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CustomerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CustomerMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CustomerMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Customer unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CustomerMutation) ResetEdge(name string) error {
	switch name {
	case customer.EdgeBooks:
		m.ResetBooks()
		return nil
	}
	return fmt.Errorf("unknown Customer edge %s", name)
}

// KidMutation represents an operation that mutate the Kids
// nodes in the graph.
type KidMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_Amount       *int
	add_Amount    *int
	clearedFields map[string]struct{}
	books         map[int]struct{}
	removedbooks  map[int]struct{}
	done          bool
	oldValue      func(context.Context) (*Kid, error)
}

var _ ent.Mutation = (*KidMutation)(nil)

// kidOption allows to manage the mutation configuration using functional options.
type kidOption func(*KidMutation)

// newKidMutation creates new mutation for $n.Name.
func newKidMutation(c config, op Op, opts ...kidOption) *KidMutation {
	m := &KidMutation{
		config:        c,
		op:            op,
		typ:           TypeKid,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withKidID sets the id field of the mutation.
func withKidID(id int) kidOption {
	return func(m *KidMutation) {
		var (
			err   error
			once  sync.Once
			value *Kid
		)
		m.oldValue = func(ctx context.Context) (*Kid, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Kid.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withKid sets the old Kid of the mutation.
func withKid(node *Kid) kidOption {
	return func(m *KidMutation) {
		m.oldValue = func(context.Context) (*Kid, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m KidMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m KidMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *KidMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetAmount sets the Amount field.
func (m *KidMutation) SetAmount(i int) {
	m._Amount = &i
	m.add_Amount = nil
}

// Amount returns the Amount value in the mutation.
func (m *KidMutation) Amount() (r int, exists bool) {
	v := m._Amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old Amount value of the Kid.
// If the Kid object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *KidMutation) OldAmount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAmount is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds i to Amount.
func (m *KidMutation) AddAmount(i int) {
	if m.add_Amount != nil {
		*m.add_Amount += i
	} else {
		m.add_Amount = &i
	}
}

// AddedAmount returns the value that was added to the Amount field in this mutation.
func (m *KidMutation) AddedAmount() (r int, exists bool) {
	v := m.add_Amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount reset all changes of the "Amount" field.
func (m *KidMutation) ResetAmount() {
	m._Amount = nil
	m.add_Amount = nil
}

// AddBookIDs adds the books edge to Books by ids.
func (m *KidMutation) AddBookIDs(ids ...int) {
	if m.books == nil {
		m.books = make(map[int]struct{})
	}
	for i := range ids {
		m.books[ids[i]] = struct{}{}
	}
}

// RemoveBookIDs removes the books edge to Books by ids.
func (m *KidMutation) RemoveBookIDs(ids ...int) {
	if m.removedbooks == nil {
		m.removedbooks = make(map[int]struct{})
	}
	for i := range ids {
		m.removedbooks[ids[i]] = struct{}{}
	}
}

// RemovedBooks returns the removed ids of books.
func (m *KidMutation) RemovedBooksIDs() (ids []int) {
	for id := range m.removedbooks {
		ids = append(ids, id)
	}
	return
}

// BooksIDs returns the books ids in the mutation.
func (m *KidMutation) BooksIDs() (ids []int) {
	for id := range m.books {
		ids = append(ids, id)
	}
	return
}

// ResetBooks reset all changes of the "books" edge.
func (m *KidMutation) ResetBooks() {
	m.books = nil
	m.removedbooks = nil
}

// Op returns the operation name.
func (m *KidMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Kid).
func (m *KidMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *KidMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Amount != nil {
		fields = append(fields, kid.FieldAmount)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *KidMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case kid.FieldAmount:
		return m.Amount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *KidMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case kid.FieldAmount:
		return m.OldAmount(ctx)
	}
	return nil, fmt.Errorf("unknown Kid field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *KidMutation) SetField(name string, value ent.Value) error {
	switch name {
	case kid.FieldAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Kid field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *KidMutation) AddedFields() []string {
	var fields []string
	if m.add_Amount != nil {
		fields = append(fields, kid.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *KidMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case kid.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *KidMutation) AddField(name string, value ent.Value) error {
	switch name {
	case kid.FieldAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Kid numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *KidMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *KidMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *KidMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Kid nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *KidMutation) ResetField(name string) error {
	switch name {
	case kid.FieldAmount:
		m.ResetAmount()
		return nil
	}
	return fmt.Errorf("unknown Kid field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *KidMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.books != nil {
		edges = append(edges, kid.EdgeBooks)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *KidMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case kid.EdgeBooks:
		ids := make([]ent.Value, 0, len(m.books))
		for id := range m.books {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *KidMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedbooks != nil {
		edges = append(edges, kid.EdgeBooks)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *KidMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case kid.EdgeBooks:
		ids := make([]ent.Value, 0, len(m.removedbooks))
		for id := range m.removedbooks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *KidMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *KidMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *KidMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Kid unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *KidMutation) ResetEdge(name string) error {
	switch name {
	case kid.EdgeBooks:
		m.ResetBooks()
		return nil
	}
	return fmt.Errorf("unknown Kid edge %s", name)
}

// RoomMutation represents an operation that mutate the Rooms
// nodes in the graph.
type RoomMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_Roomtype     *string
	clearedFields map[string]struct{}
	books         map[int]struct{}
	removedbooks  map[int]struct{}
	done          bool
	oldValue      func(context.Context) (*Room, error)
}

var _ ent.Mutation = (*RoomMutation)(nil)

// roomOption allows to manage the mutation configuration using functional options.
type roomOption func(*RoomMutation)

// newRoomMutation creates new mutation for $n.Name.
func newRoomMutation(c config, op Op, opts ...roomOption) *RoomMutation {
	m := &RoomMutation{
		config:        c,
		op:            op,
		typ:           TypeRoom,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoomID sets the id field of the mutation.
func withRoomID(id int) roomOption {
	return func(m *RoomMutation) {
		var (
			err   error
			once  sync.Once
			value *Room
		)
		m.oldValue = func(ctx context.Context) (*Room, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Room.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRoom sets the old Room of the mutation.
func withRoom(node *Room) roomOption {
	return func(m *RoomMutation) {
		m.oldValue = func(context.Context) (*Room, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoomMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoomMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *RoomMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetRoomtype sets the Roomtype field.
func (m *RoomMutation) SetRoomtype(s string) {
	m._Roomtype = &s
}

// Roomtype returns the Roomtype value in the mutation.
func (m *RoomMutation) Roomtype() (r string, exists bool) {
	v := m._Roomtype
	if v == nil {
		return
	}
	return *v, true
}

// OldRoomtype returns the old Roomtype value of the Room.
// If the Room object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RoomMutation) OldRoomtype(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRoomtype is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRoomtype requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoomtype: %w", err)
	}
	return oldValue.Roomtype, nil
}

// ResetRoomtype reset all changes of the "Roomtype" field.
func (m *RoomMutation) ResetRoomtype() {
	m._Roomtype = nil
}

// AddBookIDs adds the books edge to Books by ids.
func (m *RoomMutation) AddBookIDs(ids ...int) {
	if m.books == nil {
		m.books = make(map[int]struct{})
	}
	for i := range ids {
		m.books[ids[i]] = struct{}{}
	}
}

// RemoveBookIDs removes the books edge to Books by ids.
func (m *RoomMutation) RemoveBookIDs(ids ...int) {
	if m.removedbooks == nil {
		m.removedbooks = make(map[int]struct{})
	}
	for i := range ids {
		m.removedbooks[ids[i]] = struct{}{}
	}
}

// RemovedBooks returns the removed ids of books.
func (m *RoomMutation) RemovedBooksIDs() (ids []int) {
	for id := range m.removedbooks {
		ids = append(ids, id)
	}
	return
}

// BooksIDs returns the books ids in the mutation.
func (m *RoomMutation) BooksIDs() (ids []int) {
	for id := range m.books {
		ids = append(ids, id)
	}
	return
}

// ResetBooks reset all changes of the "books" edge.
func (m *RoomMutation) ResetBooks() {
	m.books = nil
	m.removedbooks = nil
}

// Op returns the operation name.
func (m *RoomMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Room).
func (m *RoomMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *RoomMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Roomtype != nil {
		fields = append(fields, room.FieldRoomtype)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *RoomMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case room.FieldRoomtype:
		return m.Roomtype()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *RoomMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case room.FieldRoomtype:
		return m.OldRoomtype(ctx)
	}
	return nil, fmt.Errorf("unknown Room field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RoomMutation) SetField(name string, value ent.Value) error {
	switch name {
	case room.FieldRoomtype:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoomtype(v)
		return nil
	}
	return fmt.Errorf("unknown Room field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *RoomMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *RoomMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RoomMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Room numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *RoomMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *RoomMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoomMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Room nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *RoomMutation) ResetField(name string) error {
	switch name {
	case room.FieldRoomtype:
		m.ResetRoomtype()
		return nil
	}
	return fmt.Errorf("unknown Room field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *RoomMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.books != nil {
		edges = append(edges, room.EdgeBooks)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *RoomMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case room.EdgeBooks:
		ids := make([]ent.Value, 0, len(m.books))
		for id := range m.books {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *RoomMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedbooks != nil {
		edges = append(edges, room.EdgeBooks)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *RoomMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case room.EdgeBooks:
		ids := make([]ent.Value, 0, len(m.removedbooks))
		for id := range m.removedbooks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *RoomMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *RoomMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *RoomMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Room unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *RoomMutation) ResetEdge(name string) error {
	switch name {
	case room.EdgeBooks:
		m.ResetBooks()
		return nil
	}
	return fmt.Errorf("unknown Room edge %s", name)
}

// RoomamountMutation represents an operation that mutate the Roomamounts
// nodes in the graph.
type RoomamountMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_Amount       *int
	add_Amount    *int
	clearedFields map[string]struct{}
	books         map[int]struct{}
	removedbooks  map[int]struct{}
	done          bool
	oldValue      func(context.Context) (*Roomamount, error)
}

var _ ent.Mutation = (*RoomamountMutation)(nil)

// roomamountOption allows to manage the mutation configuration using functional options.
type roomamountOption func(*RoomamountMutation)

// newRoomamountMutation creates new mutation for $n.Name.
func newRoomamountMutation(c config, op Op, opts ...roomamountOption) *RoomamountMutation {
	m := &RoomamountMutation{
		config:        c,
		op:            op,
		typ:           TypeRoomamount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoomamountID sets the id field of the mutation.
func withRoomamountID(id int) roomamountOption {
	return func(m *RoomamountMutation) {
		var (
			err   error
			once  sync.Once
			value *Roomamount
		)
		m.oldValue = func(ctx context.Context) (*Roomamount, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Roomamount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRoomamount sets the old Roomamount of the mutation.
func withRoomamount(node *Roomamount) roomamountOption {
	return func(m *RoomamountMutation) {
		m.oldValue = func(context.Context) (*Roomamount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoomamountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoomamountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *RoomamountMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetAmount sets the Amount field.
func (m *RoomamountMutation) SetAmount(i int) {
	m._Amount = &i
	m.add_Amount = nil
}

// Amount returns the Amount value in the mutation.
func (m *RoomamountMutation) Amount() (r int, exists bool) {
	v := m._Amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old Amount value of the Roomamount.
// If the Roomamount object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RoomamountMutation) OldAmount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAmount is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds i to Amount.
func (m *RoomamountMutation) AddAmount(i int) {
	if m.add_Amount != nil {
		*m.add_Amount += i
	} else {
		m.add_Amount = &i
	}
}

// AddedAmount returns the value that was added to the Amount field in this mutation.
func (m *RoomamountMutation) AddedAmount() (r int, exists bool) {
	v := m.add_Amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount reset all changes of the "Amount" field.
func (m *RoomamountMutation) ResetAmount() {
	m._Amount = nil
	m.add_Amount = nil
}

// AddBookIDs adds the books edge to Books by ids.
func (m *RoomamountMutation) AddBookIDs(ids ...int) {
	if m.books == nil {
		m.books = make(map[int]struct{})
	}
	for i := range ids {
		m.books[ids[i]] = struct{}{}
	}
}

// RemoveBookIDs removes the books edge to Books by ids.
func (m *RoomamountMutation) RemoveBookIDs(ids ...int) {
	if m.removedbooks == nil {
		m.removedbooks = make(map[int]struct{})
	}
	for i := range ids {
		m.removedbooks[ids[i]] = struct{}{}
	}
}

// RemovedBooks returns the removed ids of books.
func (m *RoomamountMutation) RemovedBooksIDs() (ids []int) {
	for id := range m.removedbooks {
		ids = append(ids, id)
	}
	return
}

// BooksIDs returns the books ids in the mutation.
func (m *RoomamountMutation) BooksIDs() (ids []int) {
	for id := range m.books {
		ids = append(ids, id)
	}
	return
}

// ResetBooks reset all changes of the "books" edge.
func (m *RoomamountMutation) ResetBooks() {
	m.books = nil
	m.removedbooks = nil
}

// Op returns the operation name.
func (m *RoomamountMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Roomamount).
func (m *RoomamountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *RoomamountMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Amount != nil {
		fields = append(fields, roomamount.FieldAmount)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *RoomamountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case roomamount.FieldAmount:
		return m.Amount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *RoomamountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case roomamount.FieldAmount:
		return m.OldAmount(ctx)
	}
	return nil, fmt.Errorf("unknown Roomamount field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RoomamountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case roomamount.FieldAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Roomamount field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *RoomamountMutation) AddedFields() []string {
	var fields []string
	if m.add_Amount != nil {
		fields = append(fields, roomamount.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *RoomamountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case roomamount.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RoomamountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case roomamount.FieldAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Roomamount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *RoomamountMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *RoomamountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoomamountMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Roomamount nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *RoomamountMutation) ResetField(name string) error {
	switch name {
	case roomamount.FieldAmount:
		m.ResetAmount()
		return nil
	}
	return fmt.Errorf("unknown Roomamount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *RoomamountMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.books != nil {
		edges = append(edges, roomamount.EdgeBooks)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *RoomamountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case roomamount.EdgeBooks:
		ids := make([]ent.Value, 0, len(m.books))
		for id := range m.books {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *RoomamountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedbooks != nil {
		edges = append(edges, roomamount.EdgeBooks)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *RoomamountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case roomamount.EdgeBooks:
		ids := make([]ent.Value, 0, len(m.removedbooks))
		for id := range m.removedbooks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *RoomamountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *RoomamountMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *RoomamountMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Roomamount unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *RoomamountMutation) ResetEdge(name string) error {
	switch name {
	case roomamount.EdgeBooks:
		m.ResetBooks()
		return nil
	}
	return fmt.Errorf("unknown Roomamount edge %s", name)
}
